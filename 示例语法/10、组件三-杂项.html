<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8" />
		<title></title>
		<script src="js/vue.js"></script>
		<link rel="stylesheet" type="text/css" href="css/base_layout.css" />
		<script type="text/javascript">
			var a;
			console.log(a);
		</script>
	</head>

	<body>

		<h3>#子组件索引</h3>
		<p>
			尽管有 props 和 events ，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用
			<font style="color: #FFB000;">ref</font> 为子组件指定一个索引 ID 。例如：
		</p>
		<div id="parent">
			<user-profile ref="profile">子组件中没有slot，所以我是不会被显示出来的</user-profile>
			<button v-on:click="getChildCounter">修改子组件数据</button>
		</div>
		<p>
			<img src="img/17.png" />
		</p>

		<h3>#异步组件</h3>
		<p>待学习，结合webpack</p>
		<p>
			<img src="img/18.png" />
		</p>
		<p>
			<img src="img/19.png"/>
		</p>
		<h3>#组件命名规定</h3>
		<p>
			<img src="img/20.png"/>
		</p>
		<p>
			<img src="img/21.png"/>
		</p>
		
		<h3>#递归组件</h3>
		<h3>#组件间的循环引用</h3>
		<p>待定！！！！！！！！！！！！！！！！！</p>
		
		<h3>#内联模板</h3>
		<p>
			如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活:
		</p>
		<div id="inlineVue">
			<user-profile inline-template>
			  <div>
			    <p>These are compiled as the component's own template.</p>
			    <p>Not parent's transclusion content.</p>
			    <p>简单来说，虽然子组件中没有slot，但是父组件（父tempalte）有inline-template这个属性，所以相当于优先级高了！“我”被显示出来了</p>
			    <p>但是子组件中的内容被去除了：counter</p>
			  </div>
			</user-profile>
		</div>
		<br />
		<p>
			但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素。
		</p>
		<p>还有种X-Template的方式也可以定义模板，但不提倡</p>
		<p>
			<img src="img/22.png"/>
		</p>
		
		<p>#对低开销的静态组件使用v-once</p>
		<p>template本质就是一静态字符串，vue需对其进行渲染，当template含有大量静态资源时，可考虑进行缓存，如：</p>
		<p>
			<img src="img/24.png"/>
		</p>
		
	</body>
	<script type="text/javascript" src="js/demo10.js"></script>
 
</html>